<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMDB Go Proxy - ç®¡ç†ç•Œé¢æ¼”ç¤º</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus@2.4.4/dist/index.full.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-plus@2.4.4/dist/index.css">
    <style>
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .result-json {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-healthy { background: #67c23a; }
        .status-unhealthy { background: #f56c6c; }
        .status-unknown { background: #e6a23c; }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <div class="header">
            <h1>ğŸ¬ TMDB Go Proxy ç®¡ç†æ§åˆ¶å°</h1>
            <p>API Key: sk-12345678qwerty</p>
        </div>

        <el-tabs v-model="activeTab" @tab-click="handleTabClick">
            <!-- æ¦‚è§ˆæ ‡ç­¾é¡µ -->
            <el-tab-pane label="ğŸ“Š æ¦‚è§ˆ" name="overview">
                <div class="card-grid">
                    <el-card>
                        <template #header>
                            <div class="card-header">
                                <span class="status-indicator status-unknown" :class="healthStatusClass"></span>
                                ç³»ç»Ÿå¥åº·çŠ¶æ€
                            </div>
                        </template>
                        <p>æŸ¥çœ‹ç³»ç»Ÿè¿è¡ŒçŠ¶æ€å’ŒåŸºæœ¬ä¿¡æ¯</p>
                        <el-button type="primary" @click="checkHealth" :loading="loading.health">
                            ğŸ” æ£€æŸ¥å¥åº·çŠ¶æ€
                        </el-button>
                        <div v-if="results.health" class="result-json">
                            {{ JSON.stringify(results.health, null, 2) }}
                        </div>
                    </el-card>

                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ“ˆ æœåŠ¡å™¨ç»Ÿè®¡</div>
                        </template>
                        <p>æŸ¥çœ‹ä¸Šæ¸¸æœåŠ¡å™¨çš„è¿æ¥ç»Ÿè®¡å’Œæ€§èƒ½æŒ‡æ ‡</p>
                        <el-button type="primary" @click="getStats" :loading="loading.stats">
                            ğŸ“Š è·å–ç»Ÿè®¡ä¿¡æ¯
                        </el-button>
                        <div v-if="results.stats" class="result-json">
                            {{ JSON.stringify(results.stats, null, 2) }}
                        </div>
                    </el-card>

                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ”— ä¸Šæ¸¸ä»£ç†çŠ¶æ€</div>
                        </template>
                        <p>æŸ¥çœ‹æ£€æµ‹åˆ°çš„åµŒå¥—ä»£ç†æœåŠ¡å™¨çŠ¶æ€</p>
                        <el-button type="primary" @click="getUpstreamStatus" :loading="loading.upstream">
                            ğŸ” æ£€æŸ¥ä¸Šæ¸¸ä»£ç†
                        </el-button>
                        <div v-if="results.upstream" class="result-json">
                            {{ JSON.stringify(results.upstream, null, 2) }}
                        </div>
                    </el-card>
                </div>
            </el-tab-pane>

            <!-- ç¼“å­˜ç®¡ç†æ ‡ç­¾é¡µ -->
            <el-tab-pane label="ğŸ’¾ ç¼“å­˜ç®¡ç†" name="cache">
                <div class="card-grid">
                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ“Š ç¼“å­˜ä¿¡æ¯</div>
                        </template>
                        <p>æŸ¥çœ‹ç¼“å­˜ä½¿ç”¨æƒ…å†µå’Œç»Ÿè®¡ä¿¡æ¯</p>
                        <el-button type="primary" @click="getCacheInfo" :loading="loading.cacheInfo">
                            ğŸ“ˆ æŸ¥çœ‹ç¼“å­˜ä¿¡æ¯
                        </el-button>
                        <div v-if="results.cacheInfo" class="result-json">
                            {{ JSON.stringify(results.cacheInfo, null, 2) }}
                        </div>
                    </el-card>

                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ—‘ï¸ æ¸…é™¤ç¼“å­˜</div>
                        </template>
                        <p>æ¸…é™¤ä¸åŒç±»å‹çš„ç¼“å­˜æ•°æ®</p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <el-button type="danger" @click="clearCache('all')" :loading="loading.clearCache">
                                ğŸ’¥ æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                            </el-button>
                            <el-button type="warning" @click="clearCache('memory')" :loading="loading.clearCache">
                                ğŸ§  æ¸…é™¤å†…å­˜ç¼“å­˜
                            </el-button>
                            <el-button type="warning" @click="clearCache('l2')" :loading="loading.clearCache">
                                ğŸ’¿ æ¸…é™¤ç£ç›˜ç¼“å­˜
                            </el-button>
                        </div>
                        <div v-if="results.clearCache" class="result-json">
                            {{ JSON.stringify(results.clearCache, null, 2) }}
                        </div>
                    </el-card>

                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ” ç¼“å­˜æœç´¢</div>
                        </template>
                        <p>æŒ‰å…³é”®è¯æœç´¢ç¼“å­˜ä¸­çš„å†…å®¹</p>
                        <el-input
                            v-model="searchQuery"
                            placeholder="è¾“å…¥æœç´¢å…³é”®è¯"
                            style="margin-bottom: 10px;"
                        ></el-input>
                        <el-button type="primary" @click="searchCache" :loading="loading.searchCache">
                            ğŸ” æœç´¢ç¼“å­˜
                        </el-button>
                        <div v-if="results.searchCache" class="result-json">
                            {{ JSON.stringify(results.searchCache, null, 2) }}
                        </div>
                    </el-card>

                    <el-card>
                        <template #header>
                            <div class="card-header">ğŸ“‹ ç¼“å­˜é”®åˆ—è¡¨</div>
                        </template>
                        <p>æŸ¥çœ‹ç¼“å­˜ä¸­çš„æ‰€æœ‰é”®</p>
                        <el-input-number
                            v-model="keysLimit"
                            :min="1"
                            :max="1000"
                            style="margin-bottom: 10px;"
                        ></el-input-number>
                        <el-button type="primary" @click="getCacheKeys" :loading="loading.cacheKeys">
                            ğŸ“‹ è·å–ç¼“å­˜é”®
                        </el-button>
                        <div v-if="results.cacheKeys" class="result-json">
                            {{ JSON.stringify(results.cacheKeys, null, 2) }}
                        </div>
                    </el-card>
                </div>
            </el-tab-pane>

            <!-- ç³»ç»Ÿé…ç½®æ ‡ç­¾é¡µ -->
            <el-tab-pane label="âš™ï¸ ç³»ç»Ÿé…ç½®" name="config">
                <el-card>
                    <template #header>
                        <div class="card-header">ğŸ”§ é…ç½®ä¿¡æ¯</div>
                    </template>
                    <p>æŸ¥çœ‹å½“å‰ç³»ç»Ÿé…ç½®å‚æ•°</p>
                    <el-button type="primary" @click="getSystemConfig" :loading="loading.config">
                        âš™ï¸ è·å–é…ç½®ä¿¡æ¯
                    </el-button>
                    <div v-if="results.config" class="result-json">
                        {{ JSON.stringify(results.config, null, 2) }}
                    </div>
                </el-card>
            </el-tab-pane>
        </el-tabs>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElButton, ElCard, ElTabs, ElTabPane, ElInput, ElInputNumber, ElMessage } = ElementPlus;

        createApp({
            components: {
                ElButton,
                ElCard,
                ElTabs,
                ElTabPane,
                ElInput,
                ElInputNumber
            },
            data() {
                return {
                    activeTab: 'overview',
                    apiKey: 'sk-12345678qwerty',
                    searchQuery: '',
                    keysLimit: 50,
                    loading: {
                        health: false,
                        stats: false,
                        upstream: false,
                        cacheInfo: false,
                        clearCache: false,
                        searchCache: false,
                        cacheKeys: false,
                        config: false
                    },
                    results: {}
                }
            },
            computed: {
                healthStatusClass() {
                    if (!this.results.health) return 'status-unknown';
                    return this.results.health.status === 'healthy' ? 'status-healthy' : 'status-unhealthy';
                }
            },
            methods: {
                async apiRequest(endpoint, options = {}) {
                    const url = '/mapi' + endpoint;
                    const defaultOptions = {
                        headers: {
                            'X-API-Key': this.apiKey,
                            'Content-Type': 'application/json'
                        }
                    };

                    const finalOptions = { ...defaultOptions, ...options };

                    try {
                        const response = await fetch(url, finalOptions);
                        const data = await response.json();
                        return data;
                    } catch (error) {
                        throw new Error(error.message || 'ç½‘ç»œè¯·æ±‚å¤±è´¥');
                    }
                },

                async checkHealth() {
                    this.loading.health = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const data = {
                            status: "healthy",
                            timestamp: new Date().toISOString(),
                            uptime: "1h 23m 45s",
                            version: "tmdb-go-proxy/1.0"
                        };
                        this.$set(this.results, 'health', data);
                        ElMessage.success('å¥åº·æ£€æŸ¥æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'health', { error: error.message });
                        ElMessage.error('å¥åº·æ£€æŸ¥å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.health = false;
                    }
                },

                async getStats() {
                    this.loading.stats = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 800));
                        const data = {
                            servers: [
                                {
                                    url: "http://api.tmdb.org",
                                    status: "healthy",
                                    response_time: 245,
                                    weight: 15,
                                    requests: 1250
                                },
                                {
                                    url: "http://tmdb.movie-pilot.org",
                                    status: "healthy",
                                    response_time: 180,
                                    weight: 20,
                                    requests: 980
                                }
                            ],
                            total_requests: 2230,
                            cache_hit_rate: "78.5%"
                        };
                        this.$set(this.results, 'stats', data);
                        ElMessage.success('ç»Ÿè®¡ä¿¡æ¯è·å–æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'stats', { error: error.message });
                        ElMessage.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.stats = false;
                    }
                },

                async getUpstreamStatus() {
                    this.loading.upstream = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 600));
                        const data = {
                            detected_proxies: [
                                {
                                    url: "http://example.com:6635",
                                    version: "tmdb-go-proxy/1.0",
                                    status: "active",
                                    last_seen: new Date().toISOString()
                                }
                            ],
                            nested_proxy_detection: "enabled"
                        };
                        this.$set(this.results, 'upstream', data);
                        ElMessage.success('ä¸Šæ¸¸ä»£ç†çŠ¶æ€è·å–æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'upstream', { error: error.message });
                        ElMessage.error('è·å–ä¸Šæ¸¸ä»£ç†çŠ¶æ€å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.upstream = false;
                    }
                },

                async getCacheInfo() {
                    this.loading.cacheInfo = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 700));
                        const data = {
                            memory_cache: {
                                entries: 245,
                                size: "12.5 MB",
                                hit_rate: "85.2%"
                            },
                            disk_cache: {
                                entries: 1250,
                                size: "89.3 MB",
                                hit_rate: "92.1%"
                            },
                            total_cache_size: "101.8 MB",
                            cache_efficiency: "88.7%"
                        };
                        this.$set(this.results, 'cacheInfo', data);
                        ElMessage.success('ç¼“å­˜ä¿¡æ¯è·å–æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'cacheInfo', { error: error.message });
                        ElMessage.error('è·å–ç¼“å­˜ä¿¡æ¯å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.cacheInfo = false;
                    }
                },

                async clearCache(type = 'all') {
                    const confirmMessage = type === 'all' ?
                        'ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ç¼“å­˜å—ï¼Ÿè¿™å°†å½±å“ç³»ç»Ÿæ€§èƒ½ï¼' :
                        'ç¡®å®šè¦æ¸…é™¤' + type + 'ç¼“å­˜å—ï¼Ÿ';

                    try {
                        await this.$confirm(confirmMessage, 'ç¡®è®¤æ“ä½œ', {
                            confirmButtonText: 'ç¡®å®š',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });
                    } catch {
                        return; // ç”¨æˆ·å–æ¶ˆ
                    }

                    this.loading.clearCache = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        const data = {
                            action: "cache_cleared",
                            type: type,
                            cleared_entries: type === 'all' ? 1495 : (type === 'memory' ? 245 : 1250),
                            message: type + "ç¼“å­˜å·²æˆåŠŸæ¸…é™¤"
                        };
                        this.$set(this.results, 'clearCache', data);
                        ElMessage.success('ç¼“å­˜æ¸…é™¤æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'clearCache', { error: error.message });
                        ElMessage.error('ç¼“å­˜æ¸…é™¤å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.clearCache = false;
                    }
                },

                async searchCache() {
                    if (!this.searchQuery.trim()) {
                        ElMessage.warning('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
                        return;
                    }

                    this.loading.searchCache = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 900));
                        const data = {
                            query: this.searchQuery,
                            results: [
                                { key: "/3/movie/popular?page=1", type: "memory", size: "2.3KB" },
                                { key: "/3/movie/12345", type: "disk", size: "1.8KB" },
                                { key: "/3/search/movie?query=" + this.searchQuery, type: "memory", size: "3.1KB" }
                            ],
                            total_matches: 3
                        };
                        this.$set(this.results, 'searchCache', data);
                        ElMessage.success('ç¼“å­˜æœç´¢æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'searchCache', { error: error.message });
                        ElMessage.error('ç¼“å­˜æœç´¢å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.searchCache = false;
                    }
                },

                async getCacheKeys() {
                    this.loading.cacheKeys = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 1100));
                        const data = {
                            keys: [
                                "/3/movie/popular?page=1",
                                "/3/movie/12345",
                                "/3/configuration",
                                "/3/search/movie?query=batman",
                                "/3/genre/movie/list"
                            ].slice(0, this.keysLimit),
                            total_keys: 1495,
                            limit: this.keysLimit
                        };
                        this.$set(this.results, 'cacheKeys', data);
                        ElMessage.success('ç¼“å­˜é”®åˆ—è¡¨è·å–æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'cacheKeys', { error: error.message });
                        ElMessage.error('è·å–ç¼“å­˜é”®åˆ—è¡¨å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.cacheKeys = false;
                    }
                },

                async getSystemConfig() {
                    this.loading.config = true;
                    try {
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const data = {
                            port: 6635,
                            cache: {
                                enabled: true,
                                memory_ttl: "1h0m0s",
                                disk_ttl: "24h0m0s",
                                memory_max_size: 104857600,
                                disk_max_size: 1073741824
                            },
                            health_check: {
                                interval: "30s",
                                initial_delay: "10s"
                            },
                            upstream_servers: [
                                "http://api.tmdb.org",
                                "http://tmdb.movie-pilot.org",
                                "http://example.com:6635"
                            ]
                        };
                        this.$set(this.results, 'config', data);
                        ElMessage.success('é…ç½®ä¿¡æ¯è·å–æˆåŠŸ');
                    } catch (error) {
                        this.$set(this.results, 'config', { error: error.message });
                        ElMessage.error('è·å–é…ç½®ä¿¡æ¯å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading.config = false;
                    }
                },

                handleTabClick(tab) {
                    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ ‡ç­¾åˆ‡æ¢æ—¶çš„é€»è¾‘
                }
            },

            mounted() {
                // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥å¥åº·çŠ¶æ€
                setTimeout(() => {
                    this.checkHealth();
                }, 1000);
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>
